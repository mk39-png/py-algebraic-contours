"""
Methods to compute rational bezier curve intersections.
Heavily utilizes autogenerated code.
"""

import copy
import logging
import math

import numpy as np

from pyalgcon.core.common import (Matrix5x3f, SpatialVector1d, Vector2f,
                                  Vector3f, Vector5f, float_equal)

logger: logging.Logger = logging.getLogger(__name__)


class Interval_ink:
    """
    Inkscope version of Intervals.
    """

    def __init__(self, a: float, b: float) -> None:
        self.begin: float = a
        self.end: float = b

    def extent(self) -> float:
        return self.end - self.begin

    def max(self) -> float:
        return self.end

    def min(self) -> float:
        return self.begin

    def middle(self) -> float:
        return (self.begin + self.end) / 2

    def set_ends(self, a: float, b: float) -> None:
        if a <= b:
            self.begin = a
            self.end = b
        else:
            self.begin = b
            self.end = a

    def value_at(self, t: float) -> float:
        return (1 - t) * self.begin + t * self.end


#
# Constants
#
MAX_PRECISION = 1e-8
MIN_CLIPPED_SIZE_THRESHOLD = 0.8
H1_INTERVAL = Interval_ink(0, 0.5)
H2_INTERVAL = Interval_ink(np.nextafter(0.5, 1.0), 1.0)


def _map_to(J: Interval_ink, I: Interval_ink) -> None:
    """ 
    Maps I onto J
    """
    J.set_ends(J.value_at(I.min()), J.value_at(I.max()))


def _float_equal_ink(a: float, b: float, eps: float = 1e-9) -> bool:
    """
    Use this method specifically for the inkscape code below.
    This differs from the usual float_equal in that this uses eps = 1e-9 rather than
    eps = 1e-10 by default.
    """
    if abs(a - b) < eps:
        return True
    return False


def _point_equal(a: SpatialVector1d, b: SpatialVector1d, eps: float = 1e-6) -> bool:
    assert a.shape == (3, )
    assert b.shape == (3, )

    aa: Vector2f = np.array([a[0] / a[2], a[1] / a[2]], dtype=np.float64)
    bb: Vector2f = np.array([b[0] / b[2], b[1] / b[2]], dtype=np.float64)
    if np.linalg.norm(aa - bb) < eps:
        return True
    return False


def _lerp(t: float, a: SpatialVector1d, b: SpatialVector1d) -> SpatialVector1d:
    return (1 - t) * a + t * b


def _middle_point(p1: SpatialVector1d, p2: SpatialVector1d) -> SpatialVector1d:
    """

    """
    p1s: SpatialVector1d = np.array([p1[0] / p1[2], p1[1] / p1[2], 1])
    p2s: SpatialVector1d = np.array([p2[0] / p2[2], p2[1] / p2[2], 1])
    return _lerp(0.5, p1s, p2s)


def _is_constant(A: Matrix5x3f, precision: float = 1e-6) -> bool:
    """
    Uses original way of checking point_equal
    """
    assert A.shape == (5, 3)

    for i in range(1, 5):
        assert A[0, :].shape == (3, )
        if not _point_equal(A[0, :], A[i, :], precision):
            return False
        # if not _point_equal(A[i], A[0], precision):
            # return False
    # A = np.asarray(A)
    # return np.allclose(A, A[0], atol=precision)

    return True


def _is_constant_list(A: list[SpatialVector1d], precision: float = 1e-6) -> bool:
    """
    Uses original way of checking point_equal as to avoid translation conflicts
    """
    for i in range(1, len(A)):
        assert A[0].shape == (3, )
        assert A[i].shape == (3, )

        if not _point_equal(A[i], A[0], precision):
            return False

    return True


def check_split_criteria(q: list[SpatialVector1d]) -> bool:
    """
    Split rational curve.
    Only used in testing.
    """
    assert len(q) == 5

    degree_sum: float = 0.0
    p: list[SpatialVector1d] = [np.zeros((3, ), dtype=np.float64),
                                np.zeros((3, ), dtype=np.float64),
                                np.zeros((3, ), dtype=np.float64),
                                np.zeros((3, ), dtype=np.float64),
                                np.zeros((3, ), dtype=np.float64)]

    for i in range(5):
        # Standardize to w = 1
        p[i] = q[i] / q[i][2]
    for i in range(3):
        v1: SpatialVector1d = p[i + 1] - p[i]
        v2: SpatialVector1d = p[i + 2] - p[i + 1]
        v1 = v1 / np.linalg.norm(v1)
        v2 = v2 / np.linalg.norm(v2)
        degree_sum += math.acos(v1.dot(v2))

    if degree_sum > math.pi:
        return False
    return True


def _get_solutions(A: list[SpatialVector1d],
                   B: list[SpatialVector1d],
                   precision: float) -> list[tuple[float, float]]:
    """
    NOTE: get_solutions() passed a reference to the same Interval_ink object into iterate()
    """
    assert A[0].shape == (3, )
    assert B[0].shape == (3, )

    domsA: list[Interval_ink] = []
    domsB: list[Interval_ink] = []
    # NOTE: passing in a reference to the same Interval_ink object since it is not modified
    # inside of iterate()
    UNIT_INTERVAL = Interval_ink(0, 1)

    counter: int = 0
    counter = iterate(domsA, domsB, A, B, UNIT_INTERVAL, UNIT_INTERVAL, precision, counter)

    if len(domsA) != len(domsB):
        assert len(domsA) == len(domsB)

    xs: list[tuple[float, float]] = []
    for i, _ in enumerate(domsA):
        xs.append((domsA[i].middle(), domsB[i].middle()))

    return xs


def _left_portion(t: float, B: list[SpatialVector1d]) -> None:
    """
    Appears to be correct translation from C++ to Python
    """
    n: int = len(B)
    for i in range(1, n):
        for j in range(n - 1, i - 1, -1):
            B[j] = _lerp(t, B[j - 1], B[j])


def _right_portion(t: float, B: list[SpatialVector1d]) -> None:
    """
    Appears to be correct translation from C++ to Python
    """
    n: int = len(B)
    for i in range(1, n):
        for j in range(n - i):
            B[j] = _lerp(t, B[j], B[j + 1])


def _portion(B: list[SpatialVector1d], I: Interval_ink) -> None:
    """
    Modifies B
    """
    if _float_equal_ink(I.min(), 0.0):
        if _float_equal_ink(I.max(), 1.0):
            return
        _left_portion(I.max(), B)
        return
    _right_portion(I.min(), B)
    if _float_equal_ink(I.max(), 1.0):
        return
    t: float = I.extent() / (1 - I.min())
    _left_portion(t, B)


def _dot3(v: Vector3f, w: Vector3f) -> float:
    """
    Returns dot product.
    NOTE: for some reason, this implementation is preferred by the C++ code over the numpy.dot 
    method
    """
    assert v.shape == (3, )
    assert w.shape == (3, )
    return (v[0] * w[0] + v[1] * w[1] + v[2] * w[2])


def _cross3(v: Vector3f,  w: Vector3f) -> Vector3f:
    """
    Returns cross product.
    NOTE: for some reason, this implementation is preferred by the C++ code over the numpy.cross 
    method
    """
    assert v.shape == (3, )
    assert w.shape == (3, )
    res: Vector3f = np.zeros(shape=(3, ), dtype=np.float64)
    res[0] = v[1] * w[2] - v[2] * w[1]
    res[1] = -v[0] * w[2] + v[2] * w[0]
    res[2] = v[0] * w[1] - v[1] * w[0]

    return res

# *****************
# Clip fatline
# *****************


def _fatline(Q: Matrix5x3f,
             L_min: Vector3f,
             L_max: Vector3f) -> None:
    """Method appears to be working OK
    """
    assert Q.shape == (5, 3)
    assert L_min.shape == (3, )
    assert L_max.shape == (3, )

    nQ: int = 5
    L: Vector3f = np.zeros(shape=(3, ), dtype=np.float64)
    # L = np.cross(Q[0], Q[nQ - 1])
    L = _cross3(Q[0], Q[nQ - 1])

    assert L.shape == (3, )
    cmin: float = L[2]
    cmax: float = L[2]
    for i in range(2, nQ + 1):
        c: float = -Q[i - 1][0] * L[0] - Q[i - 1][1] * L[1]
        cmin = min(cmin, c)
        cmax = max(cmax, c)
    L_min[0] = -L[0]
    L_min[1] = -L[1]
    L_min[2] = -cmin
    L_max[0] = L[0]
    L_max[1] = L[1]
    L_max[2] = cmax


def _clipline(P: Matrix5x3f,
              L: Vector3f,
              clip_range: Vector2f) -> None:
    """
    FIXME: blackbox code
    """
    nP: int = 5
    nPf: float = float(nP - 1)

    E0: Vector3f = np.array([0,  _dot3(L, P[0]), 1], dtype=np.float64)
    En: Vector3f = np.array([1, _dot3(L, P[nP - 1]), 1], dtype=np.float64)
    Ei: Vector3f = np.ndarray(shape=(3, ), dtype=np.float64)
    L0i: Vector3f = np.zeros((3, ), dtype=np.float64)
    Lni: Vector3f = np.zeros((3, ), dtype=np.float64)
    V0i: Vector3f = np.zeros((3, ), dtype=np.float64)
    Vni: Vector3f = np.zeros((3, ), dtype=np.float64)
    v0x: Vector5f = np.zeros((5, ), dtype=np.float64)
    v0x[0] = 0.0e0
    vnx: Vector5f = np.zeros((5, ), dtype=np.float64)
    vnx[nP - 1] = 0.0e0
    ey: Vector3f = np.array([0, 1, 0], dtype=np.float64)
    t1: float
    t2: float

    for i in range(1, nP + 1):
        Ei[0] = float(i - 1) / nPf
        Ei[1] = _dot3(L, P[i - 1])
        Ei[2] = 1
        L0i = _cross3(E0, Ei)
        Lni = _cross3(En, Ei)

        if 1 < i:
            V0i = _cross3(L0i, ey)
            v0x[i - 1] = V0i[0] / V0i[2]
        if i < nP:
            # NOTE: division by 0 is fine as that's to be expected in the C++ code as well
            Vni = _cross3(Lni, ey)
            vnx[i - 1] = Vni[0] / Vni[2]

    if 0.0e0 <= E0[1]:
        t1 = 0.0e0
    else:
        t1 = 0.1e1
        for j in range(2, nP + 1):
            if 0.0e0 < v0x[j - 1]:
                t1 = min(t1, v0x[j - 1])

    if 0.0e0 <= En[1]:
        t2 = 0.1e1
    else:
        t2 = 0.0e0
        for j in range(1, nP):
            if vnx[j - 1] < 0.1e1:
                t2 = max(t2, vnx[j - 1])

    if t2 <= t1:
        clip_range[0] = -0.1e1
        clip_range[1] = -0.1e1
    else:
        clip_range[0] = t1
        clip_range[1] = t2


def _clipfatline(P: Matrix5x3f,
                 Q: Matrix5x3f,
                 clip_range: Vector2f,
                 precision: float = 1e-8) -> None:
    """
    :param P: [in]
    :param Q: [in]
    :param clip_range: [out]
    """
    assert P.shape == (5, 3)
    assert Q.shape == (5, 3)
    assert clip_range.shape == (2, )

    for i in range(5):
        Q[i][0] /= Q[i][2]
        Q[i][1] /= Q[i][2]
        Q[i][2] = 1
    L_min: Vector3f = np.zeros(shape=(3, ))
    L_max: Vector3f = np.zeros(shape=(3, ))
    t_min: Vector2f = np.zeros(shape=(2, ))
    t_max: Vector2f = np.zeros(shape=(2, ))
    if _is_constant(Q, precision):
        if _is_constant(P, precision):
            clip_range[0] = 0
            clip_range[1] = 1
            return
        else:
            direction: Vector2f = np.array([-(P[4][1] / P[4][2] - P[0][1] / P[0][2]),
                                            P[4][0] / P[4][2] - P[0][0] / P[0][2]])
            direction = direction / np.linalg.norm(direction)
            L_min[0] = direction[1]
            L_min[1] = -direction[0]
            L_min[2] = (-direction[1] * (Q[0][0] + Q[4][0]) / 2 +
                        direction[0] * (Q[0][1] + Q[4][1]) / 2)
            L_max[0] = -direction[1]
            L_max[1] = direction[0]
            L_max[2] = (direction[1] * (Q[0][0] + Q[4][0]) / 2 -
                        direction[0] * (Q[0][1] + Q[4][1]) / 2)
    else:
        _fatline(Q, L_min, L_max)

    _clipline(P, L_min, t_min)
    _clipline(P, L_max, t_max)
    if t_min[0] == -0.1e1 or t_max[0] == -0.1e1:
        clip_range[0] = -1
        clip_range[1] = -1
    else:
        clip_range[0] = max(t_max[0], t_min[0])
        clip_range[1] = min(t_min[1], t_max[1])

# *****************
# InkScope code
# *****************


def iterate(domsA: list[Interval_ink],
            domsB: list[Interval_ink],
            A_const: list[SpatialVector1d],
            B_const: list[SpatialVector1d],
            domA_const: Interval_ink,
            domB_const: Interval_ink,
            precision: float,
            counter: int) -> int:
    """
    Inkscope code
    # FIXME potential problem with translation of C++ pointers
    Passes and returns precision to caller method 

    :param domsA: [in, out]
    :param domsB: [in, out]
    :param A: [in]
    :param B: [in]
    :param domA: [in]
    :param domB: [in]
    :param precision: [in]
    :param counter: [in, out]

    :return counter:
    """
    # Base case in order to limit recursion
    if (_float_equal_ink(domA_const.extent(), 1.0) and
            _float_equal_ink(domB_const.extent(), 1.0)):
        counter = 0

    counter += 1
    if counter > 100:
        return counter

    if precision < 1e-8:
        precision = 1e-8

    pA: list[SpatialVector1d] = copy.deepcopy(A_const)
    pB: list[SpatialVector1d] = copy.deepcopy(B_const)
    C1: list[SpatialVector1d] = pA
    C2: list[SpatialVector1d] = pB
    dompA: Interval_ink = copy.deepcopy(domA_const)
    dompB: Interval_ink = copy.deepcopy(domB_const)
    dom1: Interval_ink = dompA
    dom2: Interval_ink = dompB

    if _is_constant_list(A_const, precision) and _is_constant_list(B_const, precision):
        m1: SpatialVector1d = _middle_point(C1[0], C1[-1])
        m2: SpatialVector1d = _middle_point(C2[0], C2[-1])
        if _point_equal(m1, m2):
            domsA.append(copy.deepcopy(domA_const))
            domsB.append(copy.deepcopy(domB_const))

        return counter

    iteration = 0
    while ((iteration + 1) < 100) and (dompA.extent() >= precision or dompB.extent() >= precision):
        iteration += 1

        # Converting list[SpatialVector] to Matrix5x3f
        P: Matrix5x3f = np.zeros((5, 3), dtype=np.float64)
        Q: Matrix5x3f = np.zeros((5, 3), dtype=np.float64)
        clip_range: Vector2f = np.zeros((2, ), dtype=np.float64)
        assert len(C1) == 5
        assert len(C2) == 5
        for i in range(5):
            P[i][0] = C1[i][0]
            P[i][1] = C1[i][1]
            P[i][2] = C1[i][2]
            Q[i][0] = C2[i][0]
            Q[i][1] = C2[i][1]
            Q[i][2] = C2[i][2]

        _clipfatline(Q, P, clip_range, precision)

        dom: Interval_ink = Interval_ink(clip_range[0], clip_range[1])

        if (_float_equal_ink(dom.max(), -1.0) and _float_equal_ink(dom.min(), -1.0)):
            return counter

        # All other cases where dom[0] > dom[1] are invalid
        assert dom.min() <= dom.max()

        _map_to(dom2, dom)
        _portion(C2, dom)

        if _is_constant_list(C2, precision) and _is_constant_list(C1, precision):
            m1: SpatialVector1d = _middle_point(C1[0], C1[-1])
            m2: SpatialVector1d = _middle_point(C2[0], C2[-1])

            if _point_equal(m1, m2):
                break  # append the new interval
            else:
                return counter  # exit without appending any new interval

        # if we have clipped less than 20% than we need to subdive the curve
        # with the largest domain into two sub-curves
        if dom.extent() > MIN_CLIPPED_SIZE_THRESHOLD:
            pC1: list[SpatialVector1d]
            pC2: list[SpatialVector1d]
            dompC1: Interval_ink
            dompC2: Interval_ink
            if dompA.extent() > dompB.extent():
                pC1 = copy.deepcopy(pA)
                pC2 = copy.deepcopy(pA)
                _portion(pC1, H1_INTERVAL)
                _portion(pC2, H2_INTERVAL)
                dompC1 = copy.deepcopy(dompA)
                dompC2 = copy.deepcopy(dompA)
                _map_to(dompC1, H1_INTERVAL)
                _map_to(dompC2, H2_INTERVAL)
                counter = iterate(domsA, domsB, pC1, pB, dompC1, dompB, precision, counter)
                counter = iterate(domsA, domsB, pC2, pB, dompC2, dompB, precision, counter)
            else:
                pC1 = copy.deepcopy(pB)
                pC2 = copy.deepcopy(pB)
                _portion(pC1, H1_INTERVAL)
                _portion(pC2, H2_INTERVAL)
                dompC1 = copy.deepcopy(dompB)
                dompC2 = copy.deepcopy(dompB)
                _map_to(dompC1, H1_INTERVAL)
                _map_to(dompC2, H2_INTERVAL)
                counter = iterate(domsB, domsA, pC1, pA, dompC1, dompA, precision, counter)
                counter = iterate(domsB, domsA, pC2, pA, dompC2, dompA, precision, counter)
            return counter

        C1, C2 = C2, C1
        dom1, dom2 = dom2, dom1

    domsA.append(dompA)
    domsB.append(dompB)
    return counter


def find_intersections_bezier_clipping(
        A: list[SpatialVector1d],
        B: list[SpatialVector1d],
        precision: float) -> list[tuple[float, float]]:
    """
    Split rational bezier curves into 2
    """
    xs: list[tuple[float, float]] = _get_solutions(A, B, precision)
    return xs


def _split_bezier_curve(p: list[SpatialVector1d], t: float) -> tuple[list[SpatialVector1d],
                                                                     list[SpatialVector1d]]:
    """
    Only used in testing.
    """
    q: list[SpatialVector1d] = [np.zeros((3, )),
                                np.zeros((3, )),
                                np.zeros((3, )),
                                np.zeros((3, )),
                                np.zeros((3, ))]

    r: list[SpatialVector1d] = [np.zeros((3, )),
                                np.zeros((3, )),
                                np.zeros((3, )),
                                np.zeros((3, )),
                                np.zeros((3, ))]

    # De Casteljau's Algo
    # 5th level
    q[0] = p[0]
    r[4] = p[4]
    # 4th level
    q[1] = (1 - t) * p[0] + t * p[1]
    m1: SpatialVector1d = (1 - t) * p[1] + t * p[2]
    m2: SpatialVector1d = (1 - t) * p[2] + t * p[3]
    r[3] = (1 - t) * p[3] + t * p[4]
    # 3rd level
    q[2] = (1 - t) * q[1] + t * m1
    m3: SpatialVector1d = (1 - t) * m1 + t * m2
    r[2] = (1 - t) * m2 + t * r[3]
    # 2nd level
    q[3] = (1 - t) * q[2] + t * m3
    r[1] = (1 - t) * m3 + t * r[2]
    # 1st level
    q[4] = (1 - t) * q[3] + t * r[1]
    r[0] = q[4]

    return q, r


def split_bezier_curve_no_self_intersection(p: list[SpatialVector1d],
                                            start: float,
                                            end: float,
                                            split_point_params_ref: list[float]) -> None:
    """
    Recursive function.
    Only used in testing.
    """
    if check_split_criteria(p):
        return
    if float_equal(start, end):
        logger.error("Split until interval length zero")
        return

    q: list[SpatialVector1d]
    r: list[SpatialVector1d]
    q, r = _split_bezier_curve(p, 0.5)
    split_point_params_ref.append((start + end) / 2.0)
    split_bezier_curve_no_self_intersection(
        q, start, (start + end) / 2.0, split_point_params_ref)
    split_bezier_curve_no_self_intersection(
        r, (start + end) / 2.0, end, split_point_params_ref)
