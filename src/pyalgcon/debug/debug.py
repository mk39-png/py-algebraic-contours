"""
debug.py

Holds methods for comparing NumPy matrices to Eigen matrices, 
Python types to C++ types (i.e. AffineManifold from PYASOC to ASOC), and
also data used for inline testing.

So, these are conversions of the common.py methods that parse from file.

Utilizes and centralizes absolute file paths.
"""

import csv
import logging
import pathlib
from typing import Any  # used for testing

import numpy as np
import numpy.testing as npt

from pyalgcon.core.affine_manifold import (EdgeManifoldChart,
                                           FaceManifoldChart,
                                           VertexManifoldChart)
from pyalgcon.core.common import FLOAT_EQUAL_PRECISION, Vector1D, load_json

logger: logging.Logger = logging.getLogger(__name__)

# **********************
# Debug/Helper Methods (keep here for now, especially when comparing later contours code)
# **********************


# def compare_intersection_points(filename: str,
#                                 numpy_array: np.ndarray,
#                                 num_intersections: int) -> None:
#     """
#     Special function of compare_eigen_numpy() that takes in num_intersections and ignores the
#     rest of the irrelevant parts of the matrix to compare.
#     Since the original C++ code only initializes the values of the points that are relevant.
#     e.g
#     ACTUAL: array([[0.108474, 0.195645],
#               [0.      , 0.      ],
#               [0.      , 0.      ],
#               [0.      , 0.      ]])
#     DESIRED: array([[1.084738e-001, 1.956454e-001],
#           [6.953336e-310, 2.470328e-323],
#           [6.953336e-310, 4.728331e-310],
#           [0.000000e+000, 1.976263e-323]])
#     But we only care about the first row since this only has 1 intersection.
#     """
#     eigen_array: np.ndarray = deserialize_eigen_matrix_csv_to_numpy(filename)
#     npt.assert_allclose(
#         numpy_array[:num_intersections], eigen_array[:num_intersections], atol=1e-5)


#
# LIST COMPARISON
#
def compare_list_list_varying_lengths_float_from_file(filepath: pathlib.Path, rows_test: list[list[float]], precision=0.0) -> None:
    """
    Used when the csv list contains list with varying list lengths.
    e.g. 
    [
    [1, 2, 3, 4],
    [1, 2],
    [5, 7, 8, 8, 19, 1],
    ]
    """
    rows_control: list[list[float]] = []

    with open(filepath, 'r', encoding='utf-8') as file:
        reader = csv.reader(file)
        for row in reader:
            parsed: list[float] = [float(x) for x in row if x.strip() != '']
            rows_control.append(parsed)
    # Make sure that both are the same length
    assert len(rows_control) == len(rows_test)
    num_rows: int = len(rows_control)

    for i in range(num_rows):
        npt.assert_allclose(np.array(rows_test[i]),
                            np.array(rows_control[i]),
                            atol=precision)


def deserialize_list_list_varying_lengths_from_file(filepath: pathlib.Path) -> list[list[int]]:
    """
    Used when the csv list contains list with varying list lengths.
    e.g. 
    [
    [1, 2, 3, 4],
    [1, 2],
    [5, 7, 8, 8, 19, 1],
    ]

    # TODO: change to be list of list of any datatype
    """
    rows_control: list[list[int]] = []

    with open(filepath, 'r', encoding='utf-8') as file:
        reader = csv.reader(file)
        for row in reader:
            parsed: list[int] = [int(x) for x in row if x.strip() != '']
            rows_control.append(parsed)

    return rows_control


#
# Affine Manifold Test utility methods
#

def compare_vertex_charts(
        vertex_charts_control: list[dict[str, Any]],
        vertex_charts_test: list['VertexManifoldChart']) -> None:
    """
    Autogenerated for testing since typing all out would be cumbersome.
    used to test the vertex charts inputs
    """
    assert len(vertex_charts_control) == len(vertex_charts_test), "Mismatch in chart count"

    for i, chart_control in enumerate(vertex_charts_control):
        control_vertex_index: int = chart_control.get("vertex_index")
        control_vertex_one_ring: list[int] = chart_control.get("vertex_one_ring")
        control_face_one_ring: list[int] = chart_control.get("face_one_ring")
        control_uv_positions: Vector1D = np.array(chart_control.get("one_ring_uv_positions"))
        control_is_boundary: bool = chart_control.get("is_boundary")
        control_is_cone: bool = chart_control.get("is_cone")
        control_is_cone_adjacent: bool = chart_control.get("is_cone_adjacent")

        vertex_chart_test: VertexManifoldChart = vertex_charts_test[i]
        test_uv_positions: np.ndarray = vertex_chart_test.one_ring_uv_positions

        assert control_vertex_index == vertex_chart_test.vertex_index
        assert control_vertex_one_ring == vertex_chart_test.vertex_one_ring
        assert control_face_one_ring == vertex_chart_test.face_one_ring
        npt.assert_allclose(test_uv_positions, control_uv_positions, atol=1e-6)
        assert control_is_boundary == vertex_chart_test.is_boundary
        assert control_is_cone == vertex_chart_test.is_cone
        assert control_is_cone_adjacent == vertex_chart_test.is_cone_adjacent


def compare_vertex_charts_from_file(filepath: pathlib.Path,
                                    vertex_charts_test: list[VertexManifoldChart]) -> None:
    """
    Used for testing
    """
    vertex_charts_control: list[dict] = load_json(filepath)
    compare_vertex_charts(vertex_charts_control, vertex_charts_test)


def compare_edge_charts(edge_charts_control: list[dict],
                        edge_charts_test: list[EdgeManifoldChart]) -> None:
    """
    Autogenerated for testing since typing all out would be cumbersome.
    used to test the edge charts inputs
    """
    assert len(edge_charts_control) == len(edge_charts_test)
    for i, chart_control in enumerate(edge_charts_control):
        control_top_face_idx: int = chart_control.get("top_face_index")
        control_bot_face_idx: int = chart_control.get("bottom_face_index")
        control_left_vert_idx: int = chart_control.get("left_vertex_index")
        control_right_vert_idx: int = chart_control.get("right_vertex_index")
        control_top_vert_idx: int = chart_control.get("top_vertex_index")
        control_bot_vert_idx: int = chart_control.get("bottom_vertex_index")
        control_left_vert_uv_posn: np.ndarray = np.array(
            chart_control.get("left_vertex_uv_position"))
        control_right_vert_uv_posn: np.ndarray = np.array(
            chart_control.get("right_vertex_uv_position"))
        control_top_vert_uv_posn: np.ndarray = np.array(chart_control.get("top_vertex_uv_position"))
        control_bottom_vert_uv_posn: np.ndarray = np.array(
            chart_control.get("bottom_vertex_uv_position"))
        control_is_boundary_control: bool = chart_control.get("is_boundary")

        edge_chart_test: EdgeManifoldChart = edge_charts_test[i]
        test_top_face_idx: int = edge_chart_test.top_face_index
        test_bot_face_idx: int = edge_chart_test.bottom_face_index
        test_left_vert_idx: int = edge_chart_test.left_vertex_index
        test_right_vert_idx: int = edge_chart_test.right_vertex_index
        test_top_vert_idx: int = edge_chart_test.top_vertex_index
        test_bot_vert_idx: int = edge_chart_test.bottom_vertex_index
        test_left_vert_uv_posn: np.ndarray = edge_chart_test.left_vertex_uv_position.flatten()
        test_right_vert_uv_posn: np.ndarray = edge_chart_test.right_vertex_uv_position.flatten()
        test_top_vert_uv_posn: np.ndarray = edge_chart_test.top_vertex_uv_position.flatten()
        test_bottom_vert_uv_posn: np.ndarray = edge_chart_test.bottom_vertex_uv_position.flatten()
        test_is_boundary_control: bool = edge_chart_test.is_boundary

        assert control_top_face_idx == test_top_face_idx
        assert control_bot_face_idx == test_bot_face_idx
        assert control_left_vert_idx == test_left_vert_idx
        assert control_right_vert_idx == test_right_vert_idx
        assert control_top_vert_idx == test_top_vert_idx
        assert control_bot_vert_idx == test_bot_vert_idx
        npt.assert_allclose(test_left_vert_uv_posn, control_left_vert_uv_posn,
                            atol=FLOAT_EQUAL_PRECISION, verbose=True)
        npt.assert_allclose(test_right_vert_uv_posn, control_right_vert_uv_posn, atol=0.001)
        npt.assert_allclose(test_top_vert_uv_posn, control_top_vert_uv_posn, atol=0.001)
        npt.assert_allclose(test_bottom_vert_uv_posn, control_bottom_vert_uv_posn, atol=0.001)
        assert control_is_boundary_control == test_is_boundary_control


def compare_edge_charts_from_file(filepath: pathlib.Path,
                                  edge_charts_test: list[EdgeManifoldChart]) -> None:
    """
    Used for testing
    """
    edge_charts_control: list[dict] = load_json(filepath)
    compare_edge_charts(edge_charts_control, edge_charts_test)


def compare_face_charts(face_charts_control: list[dict],
                        face_charts_test: list['FaceManifoldChart']) -> None:
    """
    Autogenerated for testing since typing all out would be cumbersome.
    Compare control dicts with actual FaceManifoldChart objects.
    """
    assert len(face_charts_control) == len(face_charts_test), "Mismatch in number of face charts"

    for i, chart_control in enumerate(face_charts_control):
        control_face_index: int = chart_control.get("face_index")
        control_uv_positions: np.ndarray = np.array(chart_control.get(
            "face_uv_positions"))  # list of PlanarPoint... so Nx2 shape
        # np.array(p) for p in chart_control.get("face_uv_positions")
        control_is_boundary: bool = chart_control.get("is_boundary")
        control_is_cone_adjacent: bool = chart_control.get("is_cone_adjacent")
        control_is_cone_corner: list[bool] = np.array(chart_control.get("is_cone_corner"))

        chart_test: FaceManifoldChart = face_charts_test[i]

        assert control_face_index == chart_test.face_index, f"Mismatch at face index {i}"

        # Compare UV positions one by one
        npt.assert_allclose(control_uv_positions,
                            np.array(chart_test.face_uv_positions).squeeze(),
                            atol=1e-5,
                            )

        assert control_is_boundary == chart_test.is_boundary, f"Boundary flag mismatch at face {i}"
        assert control_is_cone_adjacent == chart_test.is_cone_adjacent, f"Cone-adjacent flag mismatch at face {i}"
        npt.assert_array_equal(
            np.array(chart_test.is_cone_corner),
            np.array(control_is_cone_corner))


def compare_face_charts_from_file(filepath: pathlib.Path,
                                  face_charts_test: list[FaceManifoldChart]) -> None:
    """
    Used for testing
    """
    face_charts_control: list[dict] = load_json(filepath)
    compare_face_charts(face_charts_control, face_charts_test)
