"""
twelve_split_spline.py
Methods to generate a quadratic surface with twelve split Powell-Sabin basis
coefficients
"""
import copy
import logging
from collections import defaultdict

import igl
import numpy as np
import polyscope as ps
from cholespy import CholeskySolverD
from scipy.sparse import csr_matrix

from pyalgcon.core.affine_manifold import AffineManifold, VertexManifoldChart
from pyalgcon.core.common import (COLS, DISCRETIZATION_LEVEL, ROWS, SKY_BLUE,
                                  Index, Matrix6x3f, Matrix6x12f, Matrix12x3f,
                                  MatrixNx3f, MatrixXf, MatrixXi, Vector1D,
                                  Vector3f, unimplemented)
from pyalgcon.core.compute_boundaries import compute_face_boundary_edges
from pyalgcon.core.convex_polygon import ConvexPolygon
from pyalgcon.quadratic_spline_surface.optimize_spline_surface import (
    OptimizationParameters, build_twelve_split_spline_energy_system,
    generate_optimized_twelve_split_position_data)
from pyalgcon.quadratic_spline_surface.position_data import (
    TriangleCornerData, TriangleMidpointData, generate_corner_data_matrices,
    generate_midpoint_data_matrices)
from pyalgcon.quadratic_spline_surface.PS12_patch_coeffs import \
    PS12_patch_coeffs
from pyalgcon.quadratic_spline_surface.PS12tri_bounds_coeffs import \
    PS12tri_bounds_coeffs
from pyalgcon.quadratic_spline_surface.quadratic_spline_surface import \
    QuadraticSplineSurface
from pyalgcon.quadratic_spline_surface.quadratic_spline_surface_patch import \
    QuadraticSplineSurfacePatch

logger: logging.Logger = logging.getLogger(__name__)


class TwelveSplitSplineSurface(QuadraticSplineSurface):
    """
    A piecewise quadratic surface generated by twelve-split Powell-Sabin.

    Supports:
    - quadratic spline surface operations
    - vertex position updates

    :ivar affine_manifold: 
    :ivar face_to_patch_indices:  map from mesh faces to lists of corresponding patches
    :ivar patch_to_face_indices: map from patches to the corresponding mesh face
    :ivar corner_data: quadratic vertex position and derivative data
    :ivar midpoint_data: quadratic edge midpoint derivative data
    :ivar fit_matrix: fit matrix for the energy
    :ivar energy_hessian: hessian for the energy computation
    :ivar energy_hessian_inverse: inverse of the hessian for the energy computation
    """

    def __init__(self,
                 V: np.ndarray,
                 affine_manifold: AffineManifold,
                 optimization_params: OptimizationParameters,
                 ) -> None:
        """ 
        Maps from the input mesh faces to the patches and from patches to the faces are also 
        generated.
        Constructor for VF representation with uv coordinates and with additional data for the 
        spline inferred as determined by the parameters.

        Also calls the parent QuadraticSplineSurface class to initialize 
        the following member variables:
         * _patches
         * _hash_table

        :param V: [in] mesh vertex positions
        :param affine_manifold: [in] affine manifold structure
        :param optimization_params: [in] parameters for the spline optimization
        """
        self.__affine_manifold: AffineManifold = affine_manifold
        self.__corner_data: dict[int, dict[int, TriangleCornerData]] = defaultdict(dict)
        self.__midpoint_data: dict[int, dict[int, TriangleMidpointData]] = defaultdict(dict)

        # Generate normals
        N: MatrixNx3f = self.generate_face_normals(V, affine_manifold)

        # Generate fit matrix by setting the parametrized quadratic surface mapping factor to zero
        fit_energy: float
        fit_derivatives: Vector1D
        fit_matrix: csr_matrix
        fit_matrix_inverse: CholeskySolverD
        # Make a deep since we don't want the same parameters between
        # Fit vs Non-fit 12-split-splines
        optimization_params_fit: OptimizationParameters = copy.deepcopy(optimization_params)
        optimization_params_fit.parametrized_quadratic_surface_mapping_factor = 0.0
        fit_energy, fit_derivatives, fit_matrix, fit_matrix_inverse = (
            build_twelve_split_spline_energy_system(V, N, affine_manifold, optimization_params_fit))

        # Build full energy hessian system
        energy: float
        derivatives: Vector1D
        energy_hessian: csr_matrix
        energy_hessian_inverse: CholeskySolverD
        energy, derivatives, energy_hessian, energy_hessian_inverse = (
            build_twelve_split_spline_energy_system(V, N, affine_manifold, optimization_params))

        # Build optimized corner and midpoint data.
        # As in, initializes self.__corner_data and self.__midpoint_data
        # XXX: Below changes __corner_data and __midpoint_data by reference.
        generate_optimized_twelve_split_position_data(V,
                                                      affine_manifold,
                                                      fit_matrix,
                                                      energy_hessian_inverse,
                                                      self.__corner_data,
                                                      self.__midpoint_data)

        # Get cone corners
        # list[bool] of length 3
        is_cone_corner: list[list[bool]] = affine_manifold.compute_cone_corners()

        # Initialize position data and patches.
        face_to_patch_indices: list[list[int]]
        patch_to_face_indices: list[int]
        patches: list[QuadraticSplineSurfacePatch]
        face_to_patch_indices, patch_to_face_indices, patches = self.build_twelve_split_patches(
            self.__corner_data,
            self.__midpoint_data,
            is_cone_corner)

        # This initializes the following:
        # TODO: debug through and see if these local variables are changed after calling super()
        # This shows that Python's super class and subclass behavior of inheritance.
        self._patches: list[QuadraticSplineSurfacePatch]
        self._hash_table: list[list[list[int]]]
        super().__init__(patches)

        # Saving everything into the class
        self.__face_to_patch_indices: list[list[int]] = face_to_patch_indices
        self.__patch_to_face_indices: list[int] = patch_to_face_indices
        self.fit_matrix: csr_matrix = fit_matrix
        self.energy_hessian: csr_matrix = energy_hessian
        self.energy_hessian_inverse: CholeskySolverD = energy_hessian_inverse

    # *******************
    # Getters and setters
    # *******************

    @property
    def affine_manifold(self) -> AffineManifold:
        """
        Get the underlying affine manifold for the spline
        :return: affine manifold for the spline
        """
        return self.__affine_manifold

    @affine_manifold.setter
    def affine_manifold(self, in_affine_manifold: AffineManifold) -> None:
        """
        Sets the underlying affine_manifold for the spline.
        :return: None
        """
        self.__affine_manifold = in_affine_manifold

    @property
    def face_to_patch_indices(self) -> list[list[int]]:
        """
        Get face to patch indices
        :return: face to patch indices
        """
        return self.__face_to_patch_indices

    @property
    def patch_to_face_indices(self) -> list[int]:
        """
        Get patch to face indices
        :return: patch to face indices
        """
        return self.__patch_to_face_indices

    @property
    def corner_data(self) -> dict[int, dict[int, TriangleCornerData]]:
        """
        Get corner data for the spline
        :return: corner data
        """
        return self.__corner_data

    @property
    def midpoint_data(self) -> dict[int, dict[int, TriangleMidpointData]]:
        """
        Get midpoint data for the spline
        :return: midpoint data
        """
        return self.__midpoint_data

    # *******************
    # Public Members
    # *******************

    def update_positions(self,
                         V: MatrixXf,
                         fit_matrix: csr_matrix,
                         energy_hessian_inverse: CholeskySolverD
                         ) -> None:
        """
        Update the spline surface vertex positions for the fit.

        TODO: check if the below are returned or not.
        @param[in] V: mesh vertex positions
        :param[out] fit_matrix: fit matrix for the energy
        :param[out] energy_hessian_inverse: inverse of the hessian for the energy
        computation

        :ivar face_to_patch_indices:
        :ivar patch_to_face_indices:
        :ivar patches:
        :ivar hash_table:
        """

        affine_manifold: AffineManifold = self.affine_manifold

        # Generate normals
        N: MatrixXf = TwelveSplitSplineSurface.generate_face_normals(V, affine_manifold)

        # Build optimized corner and midpoint data
        # TODO: the below should take in corner_data and midpoint_data and then return new.
        generate_optimized_twelve_split_position_data(
            V,
            affine_manifold,
            fit_matrix,
            energy_hessian_inverse,
            self.__corner_data,
            self.__midpoint_data)

        # Get cone corners
        # list[bool] length 3
        is_cone_corner: list[list[bool]] = affine_manifold.compute_cone_corners()
        assert len(is_cone_corner[0]) == 3  # lazy length checking

        # Initialize position data and patches.
        face_to_patch_indices: list[list[int]]
        patch_to_face_indices: list[int]
        patches: list[QuadraticSplineSurfacePatch]
        face_to_patch_indices, patch_to_face_indices, patches = self.build_twelve_split_patches(
            self.__corner_data,
            self.__midpoint_data,
            is_cone_corner)

        # Initialize hash tables
        hash_table: list[list[list[int]]] = self.compute_patch_hash_tables(patches)

        # Store the values into the class
        self._patches = patches
        self._hash_table = hash_table
        self.__face_to_patch_indices = face_to_patch_indices
        self.__patch_to_face_indices = patch_to_face_indices

    def add_position_data_to_viewer(self) -> None:
        """
        Add the position data for the surface to the viewer.
        """
        # Add corner position data if it exists
        if len(self.__corner_data) != 0:
            position_matrix: MatrixXf
            first_derivative_matrix: MatrixXf
            second_derivative_matrix: MatrixXf
            position_matrix, first_derivative_matrix, second_derivative_matrix = (
                generate_corner_data_matrices(self.__corner_data))

            corner_data: ps.PointCloud = ps.register_point_cloud("corner data", position_matrix)
            corner_data.add_vector_quantity("first derivatives", first_derivative_matrix)
            corner_data.add_vector_quantity("second derivatives", second_derivative_matrix)

        # Add midpoint position data if it (and the corner data) exists
        if (not (len(self.__corner_data) == 0)) and (not (len(self.__midpoint_data) == 0)):
            position_matrix: MatrixXf
            tangent_derivative_matrix: MatrixXf
            normal_derivative_matrix: MatrixXf
            position_matrix, tangent_derivative_matrix, normal_derivative_matrix = (
                generate_midpoint_data_matrices(self.__corner_data, self.__midpoint_data))
            midpoint_data: ps.PointCloud = ps.register_point_cloud("midpoint data", position_matrix)
            midpoint_data.add_vector_quantity("tangent derivatives", tangent_derivative_matrix)
            midpoint_data.add_vector_quantity("normal derivatives", normal_derivative_matrix)

    def clear(self) -> None:
        """Clear the surface data."""
        self.__affine_manifold.clear()
        self.__corner_data.clear()
        self.__midpoint_data.clear()
        self._patches.clear()

    def view(self,
             color: tuple[float, float, float] = SKY_BLUE,
             num_subdivisions: int = DISCRETIZATION_LEVEL) -> None:
        """
        View the surface.
        @param[in] color: color for the surface in the viewer
        @param[in] num_subdivisions: number of subdivisions for the surface
        """
        self.add_surface_to_viewer(color, num_subdivisions)
        self.add_position_data_to_viewer()
        ps.show()

    # *********************************************
    # Private methods for TwelveSplitSpline class
    # *********************************************
    @staticmethod
    def build_twelve_split_patches(corner_data_ref: dict[int, dict[int, TriangleCornerData]],
                                   midpoint_data_ref: dict[int, dict[int, TriangleMidpointData]],
                                   is_cone_corner_ref: list[list[bool]]
                                   ) -> tuple[list[list[int]],
                                              list[int],
                                              list[QuadraticSplineSurfacePatch]]:
        """
        NOTE: this method is renamed from init_twelve_split_patches to build_twelve_split_patches
        to better represent what it is doing.

        corner_data of length 3
        midpoint_data of length 3
        is_cone_corner with elements of list of length 3

        :return face_to_patch_indices: [out] 
        :rtype face_to_patch_indices: list[list[int]]
        :return patch_to_face_indices: [out]
        :rtype patch_to_face_indices: list[int]
        :return patches: [out]
        :rtype patches: list[QuadraticSplineSurfacePatch]
        """
        num_faces: int = len(corner_data_ref)

        # Get number of patches per face
        patches_per_face: int = 12
        num_patches: int = patches_per_face * num_faces  # NOTE: num_patches used for reserving __patches

        # Get general patch domains to use for all faces
        patch_boundaries: list[list[Vector3f]]
        patch_boundaries = generate_twelve_split_spline_patch_patch_boundaries()
        assert len(patch_boundaries) == 12
        assert len(patch_boundaries[0]) == 3
        assert patch_boundaries[0][0].shape == (3, )

        domains: list[ConvexPolygon] = []  # list of length patches_per_face
        for i in range(patches_per_face):
            domains.append(ConvexPolygon.init_from_boundary_segments_coeffs(patch_boundaries[i]))

        # Generate map from patches to input mesh corners
        patch_to_corner_map: list[tuple[int, int]]  # list of length 12
        patch_to_corner_map = generate_twelve_split_spline_patch_patch_to_corner_map()
        assert len(patch_to_corner_map) == 12

        # Clear face to patch mappings
        # TODO: not really doing much here since we're making new lists to return
        face_to_patch_indices: list[list[int]] = [[] for _ in range(num_faces)]
        patch_to_face_indices: list[int] = []

        # Iterate over face position data
        # TODO: MOVE THIS INITIALIZATION SOMEWHERE ELSE OR HAVE THIS METHOD RETURN PATCHES AS WELL.
        # NOTE: this makes a new list of patches upon calling.
        patches: list[QuadraticSplineSurfacePatch] = []
        for face_index in range(num_faces):
            # Get surface mappings
            # list of length 12 with matrices of shape (6, 3). dtype float
            surface_mappings: list[Matrix6x3f]

            # FIXME: surface mappings is wrong...
            surface_mappings = generate_twelve_split_spline_patch_surface_mapping(
                corner_data_ref[face_index], midpoint_data_ref[face_index])
            assert len(surface_mappings) == 12

            # Add patches
            for j in range(patches_per_face):
                # Add patch to surface
                patches.append(QuadraticSplineSurfacePatch(surface_mappings[j], domains[j]))

                # Mark cones
                corner_index: int = patch_to_corner_map[j][0]
                if (corner_index >= 0) and (is_cone_corner_ref[face_index][corner_index]):
                    patch_cone_index: int = patch_to_corner_map[j][1]
                    patches[-1].mark_cone(patch_cone_index)

                # Update indices
                new_patch_index: int = len(patches) - 1
                patch_to_face_indices.append(face_index)
                face_to_patch_indices[face_index].append(new_patch_index)
                assert patch_to_face_indices[face_to_patch_indices[face_index][-1]] == face_index
                assert face_to_patch_indices[patch_to_face_indices[-1]][-1] == new_patch_index

        assert len(patches) == num_patches
        return face_to_patch_indices, patch_to_face_indices, patches

    @staticmethod
    def generate_face_normals(V: MatrixXf,
                              affine_manifold: AffineManifold) -> MatrixXf:
        """
        Helper function used by TwelveSplitSplineSurface constructor 
        and update_positions() method.

        NOTE: method made static for testing
        """
        F: MatrixXi = affine_manifold.faces

        # Compute the cones of the affine manifold
        cones: list[Index] = affine_manifold.compute_cones()

        # Get vertex normals
        N_vertices: MatrixNx3f = np.asarray(igl.per_vertex_normals(V, F),
                                            dtype=np.float64)

        # Set the face one ring normals of the cone vertices to the cone vertex
        # normal
        N: np.ndarray = np.zeros(shape=(F.shape[ROWS], 3))

        for _, ci in enumerate(cones):
            chart: VertexManifoldChart = affine_manifold.get_vertex_chart(ci)
            for _, fj in enumerate(chart.face_one_ring):
                N[fj, :] = N_vertices[ci, :]

        assert N.shape[COLS] == 3
        return N


# **************
# Public Members
# **************

def compute_twelve_split_spline_patch_boundary_edges(F: MatrixXi,
                                                     face_to_patch_indices: list[list[int]]
                                                     ) -> list[tuple[int, int]]:
    """
    Used in generation of figures, animation, and algebraic contours.

    :param F: [in] mesh faces
    :param face_to_patch_indices: [in] map from triangle mesh faces to the patches arising from it

    :return patch_boundary_edges: edges of the patch triangle domains that are boundaries
    """
    logger.info("Computing patch boundary edges for mesh with %s faces", F.shape[ROWS])  # rows
    patch_boundary_edges: list[tuple[int, int]] = []

    # Validate input
    if len(face_to_patch_indices) != F.shape[ROWS]:
        raise ValueError(f"Incompatible number of mesh faces ({F.shape[ROWS]}) \
                          and face to patch mappings ({len(face_to_patch_indices)})")

    # Get face boundary edges
    face_boundary_edges: list[tuple[int, int]] = compute_face_boundary_edges(F)

    # Get boundary patch corners
    for i, _ in enumerate(face_boundary_edges):
        # Get two patch edge corners corresponding to the face edge
        # WARNING: There are some magic numbers here from the construction
        # of the twelve split
        # FIXME Double check these numbers
        face_index: int = face_boundary_edges[i][0]
        face_vertex_index: int = (face_boundary_edges[i][1] + 1) % 3

        first_patch_index: int = face_to_patch_indices[face_index][6 + (2 * face_vertex_index)]
        first_patch_vertex_index: int = 1
        second_patch_index: int = face_to_patch_indices[face_index][7 + (2 * face_vertex_index)]
        second_patch_vertex_index: int = 0

        # Skip faces without a patch
        if (first_patch_index < 0) or (second_patch_index < 0):
            continue

        # Add patch boundary edges
        patch_boundary_edges.append((first_patch_index, first_patch_vertex_index))
        patch_boundary_edges.append((second_patch_index, second_patch_vertex_index))

    return patch_boundary_edges


# ******************************************************
# Publicly Accessible Helpers for init_twelve_split_patches
# ******************************************************

def generate_twelve_split_domain_areas() -> None:
    """
    Generate areas for the twelve split patches in the same order as the
    patch surface mappings for a given domain triangle.

    :param[in] v0: first vertex position of the domain triangle
    :param[in] v1: second vertex position of the domain triangle
    :param[in] v2: third vertex position of the domain triangle
    :param[out] patch_areas: twelve patch domain areas
    """
    unimplemented("Only used in test_assemble_matrix.cpp in original ASOC code.")


def generate_twelve_split_spline_patch_patch_boundaries() -> list[list[Vector3f]]:
    """
    Generate patch boundary equations for the twelve split patches in the same
    order as the patch surface mappings

    :return: [out] patch_boundaries: twelve patch domain boundary coefficients. 
    list of length 12 with list[Vector3f] of length 3.
    :rtype: list[list[Vector3f]]
    """
    num_patches = 12
    num_boundaries = 3
    num_coeffs = 3
    patch_boundaries: list[list[Vector3f]] = [
        [
            np.zeros(shape=(num_coeffs, ))
            for _ in range(num_boundaries)
        ]
        for _ in range(num_patches)
    ]

    assert len(patch_boundaries) == 12
    assert len(patch_boundaries[0]) == 3
    assert patch_boundaries[0][0].shape == (3, )  # lazy shape checking.
    assert patch_boundaries[0][0].ndim == 1

    # Get boundary coefficients
    bound_coeffs: np.ndarray = PS12tri_bounds_coeffs()

    # Reorganize boundary coefficients
    for i in range(num_patches):
        for j in range(num_boundaries):
            for k in range(num_coeffs):
                patch_boundaries[i][j][k] = bound_coeffs[i][j][k]

    return patch_boundaries


def generate_twelve_split_spline_patch_patch_to_corner_map() -> list[tuple[int, int]]:
    """
    Generate a map from patches to corners of the face they correspond to, or
    -1 for interior patches, and the vertex of the patch at the corner.

    NOTE: helper for init_twelve_split_patches()

    :param[out] patch_to_corner_map: face corner and patch vertex in the corner
    for each patch. list of length 12
    """
    # First six patches are interior
    patch_to_corner_map: list[tuple[int, int]] = []
    for _ in range(6):
        patch_to_corner_map.append((-1, -1))

    # Hand code the last 6 patches
    patch_to_corner_map.append((0, 1))
    patch_to_corner_map.append((1, 1))
    patch_to_corner_map.append((1, 1))
    patch_to_corner_map.append((2, 1))
    patch_to_corner_map.append((2, 1))
    patch_to_corner_map.append((0, 1))

    assert len(patch_to_corner_map) == 12
    return patch_to_corner_map


def generate_twelve_split_data_to_monomial_matrices() -> list[np.ndarray]:
    """
    Build matrices to go from position data to surface mappings

    :return: coefficient_matrices: conversion matrix. list of length 12. elements of shape (6,12)
    :rtype: list[np.ndarray]
    """

    patch_coeffs: np.ndarray = PS12_patch_coeffs()  # shape (12, 6, 12)
    coefficient_matrices: list[np.ndarray] = [np.zeros(shape=(6, 12), dtype=np.float64)
                                              for _ in range(12)]

    # TODO: could use some numpy magic... maybe
    for i in range(12):
        for j in range(6):
            for k in range(12):
                coefficient_matrices[i][j, k] = patch_coeffs[i][j][k]

    assert len(coefficient_matrices) == 12
    return coefficient_matrices


def generate_twelve_split_data_matrix(corner_data: dict[int, TriangleCornerData],
                                      midpoint_data: dict[int, TriangleMidpointData]
                                      ) -> Matrix12x3f:
    """
    Combine structured position data into a single matrix
    NOTE member variables of TriangleCornerData are shape (1, 3)
    NOTE member variables of TriangleMidpointData are shape (1, 3)

    :param corner_data: [in] data at triangle corners. length 3.
    :type corner_data: list[TriangleCornerData]
    :param midpoint_data: [in] data at triangle edge midpoints. length 3.
    :type midpoint_data: list[TriangleMidpointData]
    :return: [out] twelve_split_data: combined data. shape (12, 3)
    :rtype: Matrix12x3f
    """

    assert len(corner_data) == 3
    assert len(midpoint_data) == 3

    twelve_split_data: Matrix12x3f = np.array([
        # Vertex positions
        corner_data[0].function_value.flatten(),  # row 0
        corner_data[1].function_value.flatten(),  # row 1
        corner_data[2].function_value.flatten(),  # row 2

        # Vertex gradients
        corner_data[0].first_edge_derivative.flatten(),  # row 3
        corner_data[0].second_edge_derivative.flatten(),  # row 4
        corner_data[1].second_edge_derivative.flatten(),  # row 5
        corner_data[1].first_edge_derivative.flatten(),  # row 6
        corner_data[2].first_edge_derivative.flatten(),  # row 7
        corner_data[2].second_edge_derivative.flatten(),  # row 8

        # Edge midpoint normals in order ij, jk, ki
        midpoint_data[2].normal_derivative.flatten(),  # row 9
        midpoint_data[0].normal_derivative.flatten(),  # row 10
        midpoint_data[1].normal_derivative.flatten()  # row 11
    ], dtype=np.float64)

    assert twelve_split_data.shape == (12, 3)
    return twelve_split_data


def generate_twelve_split_spline_patch_surface_mapping(
        corner_data: dict[int, TriangleCornerData],
        midpoint_data: dict[int, TriangleMidpointData]) -> list[Matrix6x3f]:
    """
    Generate twelve spline surface patch mapping coefficient matrix from corner
    and midpoint data according to the twelve-split Powell-Sabin formula.

    NOTE: this method is accessed outside for testing
    NOTE: member variables of TriangleCornerData are shape (1, 3)
    NOTE: member variables of TriangleMidpointData are shape (1, 3)

    :param corner_data: [in] data at triangle corners. length 3
    :param midpoint_data: [in] data at triangle edge midpoints. length 3
    :return: [out] surface_mappings: spline surface mappings
    :rtype: list[Matrix6x3f]
    """
    assert len(corner_data) == 3
    assert len(midpoint_data) == 3

    # Generate matrices to go from the position data to surface coefficients
    coefficient_matrices: list[Matrix6x12f]  # list of size 12 with matrices shape (6, 12)
    coefficient_matrices = generate_twelve_split_data_to_monomial_matrices()

    # Combine position data into a matrix
    twelve_split_data: Matrix12x3f  # matrix of float with shape (12, 3)
    twelve_split_data = generate_twelve_split_data_matrix(corner_data, midpoint_data)

    # Build the surface mappings
    surface_mappings: list[Matrix6x3f] = []  # list of length 12 with matrices shape (6, 3)
    for i in range(12):
        # shape maths: element (6, 3) = cofficient_matrices (6, 12) @ twelve_split_spline (12, 3)
        surface_mappings.append(coefficient_matrices[i] @ twelve_split_data)

    assert surface_mappings[0].shape == (6, 3)  # Lazy shape checking.
    return surface_mappings
